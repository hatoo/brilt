(datatype Bool
  (True)
  (False)
)

(datatype OptionI
  (SomeI i64)
  (NoneI)
)

(datatype Expr
  (ConstInt i64 :cost 0)
  (ConstBool Bool :cost 0)
  (Arg i64)
  (Add Expr Expr)
  (Sub Expr Expr)
  (Gt Expr Expr)
)

(datatype IList
  (ConsI i64)
  (NilI)
)

(datatype StateExpr
  (SArg i64)
  (Call IList)
  (Return OptionI)
  (Print i64)
)

(sort ExprVec
  (Vec Expr)
)

(sort StateExprVec
  (Vec StateExpr)
)

(datatype OptionS
  (SomeS StateExpr)
  (NoneS)
)

(datatype Node
  (Simple ExprVec)
  (StateFul ExprVec OptionS)
  (BranchIf i64 Node Node)
)

(datatype List
  (Cons Node List)
  (Nil)
)

(function Linear (List) Node)

; Start Rules

(rewrite
  (Cons (Simple outs) (Cons (BranchIf i then else) rest))
  (Cons (Simple outs) (Cons then rest))
  :when ((= (vec-get outs i) (ConstBool (True))))
)

; https://github.com/sampsyo/bril/blob/main/examples/test/df/cond.bril
;@main {
;  a: int = const 47;
;  b: int = const 42;
;  cond: bool = const true;
;  br cond .left .right;
;.left:
;  b: int = const 1;
;  c: int = const 5;
;  jmp .end;
;.right:
;  a: int = const 2;
;  c: int = const 10;
;  jmp .end;
;.end:
;  d: int = sub a c;
;  print d;
;}

; cond is a constant. So egglog will optimize branches.
(let expr
  (Linear (Cons (Simple (vec-of (ConstInt 47) (ConstBool (True)))) (Cons (BranchIf 1 (Simple (vec-of (Arg 0) (ConstInt 5))) (Simple (vec-of (ConstInt 2) (ConstInt 10)))) (Cons (Linear (Cons (Simple (vec-of (Sub (Arg 0) (Arg 1)))) (Cons (StateFul (vec-empty) (SomeS (Print 0))) (Cons (StateFul (vec-empty) (SomeS (Return (NoneI)))) (Nil))))) (Nil)))))
)

(run 100)

(query-extract expr)
