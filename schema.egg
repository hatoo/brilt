(datatype OptionI
  (SomeI i64)
  (NoneI)
)

(datatype Expr
  (Nop)
  (ConstInt i64)
  (ConstBool bool)
  (Arg i64)
  (Add Expr Expr)
  (PtrAdd Expr Expr)
  (Sub Expr Expr)
  (Mul Expr Expr)
  (Gt Expr Expr)
  (Lt Expr Expr)
  (Eq Expr Expr)
)

(datatype ListI
  (ConsI i64 ListI)
  (NilI)
)

(datatype StateExpr
  (SArg i64)
  (Call ListI)
  (Return OptionI)
  (Print i64)
  (Alloc i64 String)
  (Free i64)
  (Load i64 String)
  (Store i64 i64)
)

(datatype ListE
  (ConsE i64 Expr ListE)
  (NilE)
)

(datatype ListS
  (ConsS i64 StateExpr ListS)
  (NilS)
)

(datatype ListII
  (ConsII i64 i64 ListII)
  (NilII)
)

(datatype OptionS
  (SomeS StateExpr)
  (NoneS)
)

; each first i64's are Node's id
(datatype Node
  (Simple i64 ListE)
  (StateFul i64 ListS OptionS)
  (BranchIf i64 i64 Node Node)
  (Loop i64 i64 Node ListII)
)

(datatype List
  (Cons Node List)
  (Nil)
)

(function Linear (i64 List) Node)

; Start Rules

; peephole

(rewrite
  (Add (ConstInt x) (ConstInt y))
  (ConstInt (+ x y))
)

(rewrite
  (Sub (ConstInt x) (ConstInt y))
  (ConstInt (- x y))
)

(rewrite
  (Mul (ConstInt x) (ConstInt y))
  (ConstInt (* x y))
)

; structure

(rewrite
  (Linear id (Cons (Linear id2 nodes) Nil))
  (Linear id2 nodes)
)

(rewrite
  (Cons (Simple id exprs) (Cons (Linear id2 exprs2) rest))
  (Cons (Linear id2 (Cons (Simple id exprs) exprs2)) rest)
)

(function append (List List) List)
(rewrite
  (append (Nil) list)
  list
)
(rewrite
  (append (Cons head tail) list)
  (Cons head (append tail list))
)
(rewrite
  (Cons (Linear id nodes) rest)
  (append nodes rest)
)

; nth expr
(relation nth (i64 i64 Expr))
(relation nth-for (i64 ListE))
(rule
  ((Simple id exprs))
  ((nth-for id exprs))
)
(rule
  ((nth-for id (ConsE i expr rest)))
  ((nth id i expr) (nth-for id rest))
)
(relation nth-for-state (i64 ListS))
(rule
  ((StateFul id exprs se))
  ((nth-for-state id exprs))
)
(rule
  ((nth-for-state id (ConsS i head rest)))
  ((nth-for-state id rest))
)
(rule
  ((nth-for-state id (ConsS i (SArg a) rest)))
  ((nth id i (Arg a)))
)

; apply optimized nth

(relation apply-nth (i64 ListE ListE))
(rule
  ((apply-nth id (ConsE i expr rest) (ConsE i expr2 rest2)))
  ((apply-nth id rest rest2))
)
(rule
  ((apply-nth id (ConsE i expr rest) (ConsE i expr rest)) (nth id i expr2) (apply-nth id rest rest2))
  ((apply-nth id (ConsE i expr rest) (ConsE i expr2 rest2)))
)
(rule
  ((Simple id exprs))
  ((apply-nth id exprs exprs))
)
(rewrite
  (Simple id exprs)
  (Simple id exprs2)
  :when ((apply-nth id exprs exprs2))
)

; branch optimization

(rewrite
  (Cons (Simple id exprs) (Cons (BranchIf id2 cond then else) rest))
  (Cons (Simple id exprs) (Cons then rest))
  :when ((nth id cond (ConstBool true)))
)

(rewrite
  (Cons (Simple id exprs) (Cons (BranchIf id2 cond then else) rest))
  (Cons (Simple id exprs) (Cons else rest))
  :when ((nth id cond (ConstBool false)))
)

; const fold

(datatype Const
  (Int i64)
  (Bool bool)
)
(relation nth-const (i64 i64 Const))
(function const-expr (Const) Expr)
(rule ((nth id i (ConstInt x))) ((nth-const id i (Int x))))
(rule ((nth id i (ConstBool b))) ((nth-const id i (Bool b))))
(rule ((Int i)) ((union (const-expr (Int i)) (ConstInt i))))
(rule ((Bool b)) ((union (const-expr (Bool b)) (ConstBool b))))

(rule
  ((Cons (Simple id exprs) (Cons (Simple id2 exprs2) rest)) (nth-const id i c) (nth id2 j (Arg i)))
  ((nth id2 j (const-expr c)))
)

; deep const fold
(relation succ (i64 i64))
(relation nodeid (Node i64))
(rule
  ((= node (Simple id exprs)))
  ((nodeid node id))
)
(rule
  ((= node (StateFul id exprs se)))
  ((nodeid node id))
)
(rule
  ((Cons node0 (Cons node1 rest)) (nodeid node0 id0) (nodeid node1 id1))
  ((succ id0 id1))
)

(relation opt-expr (i64 Expr Expr))
(rule
  ((nth id i expr))
  ((opt-expr id expr expr))
)
(rule
  ((opt-expr id expr (Arg i)) (succ idprev id) (nth-const idprev i c))
  ((opt-expr id expr (const-expr c)))
)

;; deep walk
(rule
  ((opt-expr id expr (Sub x y)))
  ((opt-expr id x x) (opt-expr id y y))
)
(rule
  ((opt-expr id expr (Sub x y)) (opt-expr id x x2) (opt-expr id y y2))
  ((opt-expr id expr (Sub x2 y2)))
)

(rule
  ((opt-expr id expr (PtrAdd x y)))
  ((opt-expr id x x) (opt-expr id y y))
)
(rule
  ((opt-expr id expr (PtrAdd x y)) (opt-expr id x x2) (opt-expr id y y2))
  ((opt-expr id expr (PtrAdd x2 y2)))
)
; apply opt-expr

(rule
  ((nth id i expr) (opt-expr id expr expr2))
  ((nth id i expr2))
)

; no deps optimize

(relation no-arg (Expr))
(rule
  ((Sub x y) (no-arg x) (no-arg y))
  ((no-arg (Sub x y)))
)
(rule
  ((ConstInt x))
  ((no-arg (ConstInt x)))
)
(rule
  ((ConstBool b))
  ((no-arg (ConstBool b)))
)

(relation no-arg-exprs (ListE))
(no-arg-exprs (NilE))
(rule
  ((ConsE i expr rest) (no-arg-exprs rest) (no-arg expr))
  ((no-arg-exprs (ConsE i expr rest)))
)

(rewrite
  (Cons (Simple id exprs) (Cons (Simple id2 exprs2) rest))
  (Cons (Simple id2 exprs2) rest)
  :when ((no-arg-exprs exprs2))
)

; use memory extention
; currrently, replace `load` by const if it's known

(datatype MemInst
  (MAlloc i64 String)
  (MFree i64)
  (MStore i64 i64)
  (MLoad i64 String)
  (MNop) ; Other state inst
)

; at node id's alloc, with offset
(datatype Pointer (Ptr i64 i64))
; at node id's nth arg is pointer
(relation nth-ptr (i64 i64 Pointer))
(relation node-meminst (i64 MemInst))

(relation mem-inst (StateExpr MemInst))
(rule
  ((= se (Alloc size ty)))
  ((mem-inst se (MAlloc size ty)))
)
(rule
  ((= se (Free id)))
  ((mem-inst se (MFree id)))
)
(rule
  ((= se (Store id1 id2)))
  ((mem-inst se (MStore id1 id2)))
)
(rule
  ((= se (Load id ty)))
  ((mem-inst se (MLoad id ty)))
)
(rule
  ((= se (Call args)))
  ((mem-inst se (MNop)))
)
(rule
  ((= se (Return opt)))
  ((mem-inst se (MNop)))
)
(rule
  ((= se (Print id)))
  ((mem-inst se (MNop)))
)

(rule
  ((StateFul id sexprs (SomeS se)) (mem-inst se minst))
  ((node-meminst id minst))
)

(relation state-for (i64 ListS))
(rule
  ((StateFul id lists se))
  ((state-for id lists))
)
(rule
  ((state-for id (ConsS i head rest)))
  ((state-for id rest))
)
(rule
  ((state-for id (ConsS i (Alloc size ty) rest)))
  ((nth-ptr id i (Ptr id 0)))
)
(rule
  ((state-for id (ConsS i sexpr rest)) (mem-inst sexpr minst))
  ((node-meminst id minst))
)

(rule
  ((succ pre suc) (nth-ptr pre i ptr) (nth suc j (Arg i)))
  ((nth-ptr suc j ptr))
)
(rule
  ((succ pre suc) (nth-ptr pre i (Ptr addr offset)) (nth suc j (PtrAdd (Arg i) (ConstInt dif))))
  ((nth-ptr suc j (Ptr addr (+ offset dif))))
)

(relation known-mem (i64 Pointer Const))
(rule
  ((succ pre i) (node-meminst i (MStore x y)) (nth-ptr pre x ptr) (nth-const pre y val))
  ((known-mem i ptr val))
)
(rule
  ((succ pre i) (node-meminst i (MLoad x s)) (known-mem pre p c))
  ((known-mem i p c))
)
(rule
  ((succ pre i) (node-meminst i (MNop)) (known-mem pre p c))
  ((known-mem i p c))
)
(rule
  ((succ pre i) (known-mem pre p c) (Simple i exprs))
  ((known-mem i p c))
)

(function replace-load (Expr ListS) ListE)
(rewrite
  (replace-load e (ConsS i (Load id ty) rest))
  (ConsE i e (replace-load e rest))
)
(rewrite
  (replace-load e (ConsS i (SArg a) rest))
  (ConsE i (Arg a) (replace-load e rest))
)
(rewrite
  (replace-load e (NilS))
  (NilE)
)
(rule
  ((= chunk (Cons pre (Cons (StateFul id sexprs se) rest))) (node-meminst id (MLoad addr ty)) (nth-ptr preid addr ptr) (known-mem id ptr c))
  ((replace-load (const-expr c) sexprs) (union chunk (Cons pre (Cons (Simple id (replace-load (const-expr c) sexprs)) rest))))
)

; Testing. Remove unneeded store
(relation no-load (i64 List))

(rule
  ((node-meminst id (MAlloc size ty)))
  ((no-load id (Nil)))
)
(rule
  ((= chunk (Cons node rest)) (nodeid node id) (node-meminst id meminst) (!= (MLoad addr ty) meminst) (no-load i rest))
  ((no-load i chunk))
)
(rule
  ((= chunk (Cons (Simple id exprs) rest)) (no-load i rest))
  ((no-load i chunk))
)
(rewrite
  (Cons node (Cons suc rest))
  (Cons node rest)
  :when ((nodeid suc sucid) (node-meminst sucid (MStore i val)) (nodeid node pre) (nth-ptr pre i (Ptr orig offset)) (no-load orig rest))
)


; https://github.com/sampsyo/bril/blob/main/examples/test/df/cond.bril
;@main {
;  a: int = const 47;
;  b: int = const 42;
;  cond: bool = const true;
;  br cond .left .right;
;.left:
;  b: int = const 1;
;  c: int = const 5;
;  jmp .end;
;.right:
;  a: int = const 2;
;  c: int = const 10;
;  jmp .end;
;.end:
;  d: int = sub a c;
;  print d;
;}

; cond is a constant. So egglog will optimize branches.
; (let expr
; (Linear 0 (Cons (Simple 1 (ConsE 0 (ConstBool true) (NilE)))
; (Cons (Simple 2 (ConsE 0 (ConstInt 1) (NilE)))
; (Cons (StateFul 3 (ConsS 0 (SArg 0) (NilS)) (SomeS (Print 0)))
; (Cons (StateFul 4 (ConsS 0 (SArg 0) (NilS)) (SomeS (Return (NoneI))))
; (Nil)
; )))))
; )


; (run 100)

; (print-function no-arg-exprs 16)

; (extract expr)

; you'll get
; @main {
; v0: int = const 42;
; print v0;
; ret;
; }
