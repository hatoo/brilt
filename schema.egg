(datatype OptionI
  (SomeI i64)
  (NoneI)
)

(datatype Expr
  (Nop)
  (ConstInt i64 :cost 0)
  (ConstBool bool :cost 0)
  (Arg i64 :cost 3)
  (Add Expr Expr)
  (Sub Expr Expr)
  (Mul Expr Expr)
  (Gt Expr Expr)
  (Lt Expr Expr)
  (Eq Expr Expr)
)

(datatype ListI
  (ConsI i64 ListI)
  (NilI)
)

(datatype StateExpr
  (SArg i64)
  (Call ListI)
  (Return OptionI)
  (Print i64)
)

(datatype ListE
  (ConsE i64 Expr ListE)
  (NilE)
)

(datatype ListS
  (ConsS i64 StateExpr ListS)
  (NilS)
)

(datatype ListII
  (ConsII i64 i64 ListII)
  (NilII)
)

(datatype OptionS
  (SomeS StateExpr)
  (NoneS)
)

(datatype Node
  (Simple ListE)
  (StateFul ListS OptionS)
  (BranchIf i64 Node Node)
  (Loop i64 Node ListII)
)

(datatype List
  (Cons Node List)
  (Nil)
)

(function Linear (List) Node)

; Start Rules

; Structure

(rewrite
  (Cons (Simple node) (Cons (Linear list2) rest))
  (Cons (Linear (Cons (Simple node) list2)) rest)
)

(rewrite
  (Linear (Cons (Linear list) (Nil)))
  (Linear list)
)

; const fold

(rewrite
  (Sub (ConstInt x) (ConstInt y))
  (ConstInt (- x y))
)

; nth expr

(function nth (ListE i64) Expr)

(rewrite
  (nth (ConsE i expr rest) i)
  expr
)

(rewrite
  (nth (ConsE i expr rest) j)
  (nth rest j)
  :when ((< i j))
)

; const at

(datatype Value
  (Int i64)
  (Boolean bool)
)

(function ConstValue (Node i64) Value)
(function const-value-expr (Value) Expr)
(function ConstExpr (Node i64) Expr)

(rewrite
  (const-value-expr (Int x))
  (ConstInt x)
)

(rewrite
  (const-value-expr (Boolean b))
  (ConstBool b)
)

(rule
  ((= v (ConstValue node i)))
  ((union (ConstExpr node i) (const-value-expr v)))
)

(rule
  ((ConstValue (Simple exprs) i))
  ((nth exprs i))
)

(rule
  ((ConstValue (Simple exprs) i) (= (ConstInt x) (nth exprs i)))
  ((union (ConstValue (Simple exprs) i) (Int x)))
)

(rule
  ((ConstValue (Simple exprs) i) (= (ConstBool b) (nth exprs i)))
  ((union (ConstValue (Simple exprs) i) (Boolean b)))
)

; const arg fold

(function ConstArgFold (Node ListE) ListE)
(sort E1)
(function ConstArgFoldExpr (Node Expr Expr) E1)

(rule
  ((ConstArgFoldExpr node (Arg i) o))
  ((ConstValue node i))
)

(rewrite
  (ConstArgFoldExpr node (Arg i) o)
  (ConstArgFoldExpr node (Arg i) (ConstExpr node i))
)

(rule
  ((ConstArgFoldExpr node (Sub x y) o))
  ((ConstArgFoldExpr node x x) (ConstArgFoldExpr node y y))
)

(rewrite
  (ConstArgFoldExpr node (Sub x y) o)
  (ConstArgFoldExpr node (Sub x y) (Sub lhs rhs))
  :when ((ConstArgFoldExpr node x lhs) (ConstArgFoldExpr node y rhs))
)

(rewrite
  (ConstArgFold node (ConsE i expr rest))
  (ConsE i o (ConstArgFold node rest))
  :when ((ConstArgFoldExpr node expr o))
)

(rewrite
  (ConstArgFold node (NilE))
  (NilE)
)

(rule
  ((Cons node (Cons (Simple exprs) rest)))
  ((ConstArgFold node exprs))
)

(rule
  ((ConstArgFold node (ConsE i expr rest)))
  ((ConstArgFoldExpr node expr expr))
)

(rule
  ((ConstArgFold node (ConsE i expr rest)))
  ((ConstArgFold node rest))
)

(rewrite
  (Cons node (Cons (Simple exprs) rest))
  (Cons node (Cons (Simple (ConstArgFold node exprs)) rest))
)

; branch optimize

(rule
  ((Cons node (Cons (BranchIf i then else) rest)))
  ((ConstValue node i))
)

(rule
  ((= p (Cons node (Cons (BranchIf i then else) rest))) (= (Boolean true) (ConstValue node i)))
  ((union p (Cons node (Cons then rest))))
)

; no deps optimize

(push)
(function NoUseArg (ListE) bool :merge (and new old))

(rule
  ((NoUseArg (ConsE i (Arg j) rest)))
  ((set (NoUseArg (ConsE i (Arg j) rest)) false))
)

(rule ((NoUseArg (ConsE i expr rest))) ((set (NoUseArg (ConsE i expr rest)) (NoUseArg rest))))
(set (NoUseArg (NilE)) true)

(rule
  ((Simple exprs))
  ((set (NoUseArg exprs) true))
)

(rewrite
  (Cons (Simple pred) (Cons (Simple exprs) rest))
  (Cons (Simple exprs) rest)
  :when ((= (NoUseArg exprs) true))
)

(pop)

; https://github.com/sampsyo/bril/blob/main/examples/test/df/cond.bril
;@main {
;  a: int = const 47;
;  b: int = const 42;
;  cond: bool = const true;
;  br cond .left .right;
;.left:
;  b: int = const 1;
;  c: int = const 5;
;  jmp .end;
;.right:
;  a: int = const 2;
;  c: int = const 10;
;  jmp .end;
;.end:
;  d: int = sub a c;
;  print d;
;}

; cond is a constant. So egglog will optimize branches.
; (let expr
; (Linear (Cons (Simple (ConsE 0 (ConstInt 47) (ConsE 1 (ConstBool (True)) (NilE)))) (Cons (BranchIf 1 (Simple (ConsE 0 (Arg 0) (ConsE 1 (ConstInt 5) (NilE)))) (Simple (ConsE 0 (ConstInt 2) (ConsE 1 (ConstInt 10) (NilE))))) (Cons (Linear (Cons (Simple (ConsE 0 (Sub (Arg 0) (Arg 1)) (NilE))) (Cons (StateFul (NilS) (SomeS (Print 0))) (Cons (StateFul (NilS) (SomeS (Return (NoneI)))) (Nil))))) (Nil)))))
; )


; (run 100)

; (print-table ConstValue)
; (extract expr)
