(datatype OptionI
  (SomeI i64)
  (NoneI)
)

(datatype Expr
  (Nop)
  (ConstInt i64 :cost 0)
  (ConstBool bool :cost 0)
  (Arg i64 :cost 3)
  (Add Expr Expr)
  (Sub Expr Expr)
  (Mul Expr Expr)
  (Gt Expr Expr)
  (Lt Expr Expr)
  (Eq Expr Expr)
)

(datatype ListI
  (ConsI i64 ListI)
  (NilI)
)

(datatype StateExpr
  (SArg i64)
  (Call ListI)
  (Return OptionI)
  (Print i64)
)

(datatype ListE
  (ConsE i64 Expr ListE)
  (NilE)
)

(datatype ListS
  (ConsS i64 StateExpr ListS)
  (NilS)
)

(datatype ListII
  (ConsII i64 i64 ListII)
  (NilII)
)

(datatype OptionS
  (SomeS StateExpr)
  (NoneS)
)

; each first i64's are Node's id
(datatype Node
  (Simple i64 ListE)
  (StateFul i64 ListS OptionS)
  (BranchIf i64 i64 Node Node)
  (Loop i64 i64 Node ListII)
)

(datatype List
  (Cons Node List)
  (Nil)
)

(function Linear (i64 List) Node)

; Start Rules

; structure

(rewrite
  (Linear id (Cons (Linear id2 nodes) Nil))
  (Linear id2 nodes)
)

(rewrite
  (Cons (Simple id exprs) (Cons (Linear id2 exprs2) rest))
  (Cons (Linear id2 (Cons (Simple id exprs) exprs2)) rest)
)

; nth expr
(relation nth (i64 i64 Expr))
(relation nth-for (i64 ListE))
(rule
  ((Simple id exprs))
  ((nth-for id exprs))
)
(rule
  ((nth-for id (ConsE i expr rest)))
  ((nth id i expr) (nth-for id rest))
)

; branch optimization

(rewrite
  (Cons (Simple id exprs) (Cons (BranchIf id2 cond then else) rest))
  (Cons (Simple id exprs) (Cons then rest))
  :when ((nth id cond (ConstBool true)))
)

(rewrite
  (Cons (Simple id exprs) (Cons (BranchIf id2 cond then else) rest))
  (Cons (Simple id exprs) (Cons else rest))
  :when ((nth id cond (ConstBool false)))
)

; https://github.com/sampsyo/bril/blob/main/examples/test/df/cond.bril
;@main {
;  a: int = const 47;
;  b: int = const 42;
;  cond: bool = const true;
;  br cond .left .right;
;.left:
;  b: int = const 1;
;  c: int = const 5;
;  jmp .end;
;.right:
;  a: int = const 2;
;  c: int = const 10;
;  jmp .end;
;.end:
;  d: int = sub a c;
;  print d;
;}

; cond is a constant. So egglog will optimize branches.
; (let expr
; (Linear 0 (Cons (Simple 1 (ConsE 0 (ConstBool true) (ConsE 1 (ConstInt 47) (NilE))))
; (Cons (BranchIf 2 0 (Simple 3 (ConsE 0 (ConstInt 5) (ConsE 1 (Arg 1) (NilE))))
; (Simple 4 (ConsE 0 (ConstInt 10) (ConsE 1 (ConstInt 2) (NilE))))
; )
; (Cons (Linear 5 (Cons (Simple 6 (ConsE 0 (Sub (Arg 1) (Arg 0)) (NilE)))
; (Cons (StateFul 7 (NilS) (SomeS (Print 0)))
; (Cons (StateFul 8 (NilS) (SomeS (Return (NoneI))))
; (Nil)
; ))))
; (Nil)
; ))))
; )


; (run 100)

; (print-size nth)
; (extract expr)
